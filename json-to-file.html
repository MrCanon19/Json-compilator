<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n8n Workflow Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 8px;
            font-size: 32px;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 15px;
        }

        .info-banner {
            background: #f0f7ff;
            border-left: 4px solid #4a90e2;
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 24px;
            font-size: 13px;
            color: #2c5282;
            line-height: 1.6;
        }

        .info-banner strong {
            color: #1a365d;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
            font-size: 14px;
        }

        textarea {
            width: 100%;
            min-height: 400px;
            padding: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.2s;
            background: #fafafa;
        }

        textarea:focus {
            outline: none;
            border-color: #4a90e2;
            background: white;
        }

        textarea.error {
            border-color: #e74c3c;
            background-color: #fee;
        }

        .filename-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .filename-input:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-download {
            background: #4a90e2;
            color: white;
        }

        .btn-download:hover {
            background: #357abd;
        }

        .btn-download:active {
            transform: translateY(0);
        }

        .btn-download:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-validate {
            background: #f5f5f5;
            color: #333;
            border: 1px solid #ddd;
        }

        .btn-validate:hover {
            background: #e8e8e8;
        }

        .btn-clear {
            background: #fff;
            color: #666;
            border: 1px solid #ddd;
        }

        .btn-clear:hover {
            background: #f5f5f5;
        }

        .message {
            margin-top: 16px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .info {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            color: #666;
            line-height: 1.7;
            border-top: 1px solid #e0e0e0;
        }

        .info strong {
            color: #333;
        }

        .file-drop-zone {
            border: 2px dashed #ddd;
            border-radius: 4px;
            padding: 24px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.2s;
            cursor: pointer;
            background: #fafafa;
        }

        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #4a90e2;
            background: #f0f7ff;
        }

        .file-drop-zone p {
            color: #666;
            margin: 5px 0;
            font-size: 14px;
        }

        .file-input-hidden {
            display: none;
        }

        .options-row {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-group {
            flex: 1;
            min-width: 150px;
        }

        .option-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .option-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .stats {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .stat-item {
            color: #666;
        }

        .stat-item strong {
            color: #333;
        }

        .btn-copy {
            background: #28a745;
            color: white;
        }

        .btn-copy:hover {
            background: #218838;
        }

        .btn-n8n {
            background: #ff6d5a;
            color: white;
        }

        .btn-n8n:hover {
            background: #e55a47;
        }

        .btn-fix {
            background: #17a2b8;
            color: white;
        }

        .btn-fix:hover {
            background: #138496;
        }

        .n8n-info {
            margin-top: 15px;
            padding: 15px;
            background: #fff3e0;
            border-left: 4px solid #ff6d5a;
            border-radius: 8px;
            font-size: 13px;
            display: none;
        }

        .n8n-info.show {
            display: block;
        }

        .n8n-info h3 {
            margin: 0 0 10px 0;
            color: #ff6d5a;
            font-size: 16px;
        }

        .n8n-info-item {
            margin: 5px 0;
            color: #666;
        }

        .n8n-info-item strong {
            color: #333;
        }

        .template-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 15px;
            background: white;
            cursor: pointer;
        }

        .template-select:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .content-type-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
            text-transform: uppercase;
        }

        .content-type-indicator.json {
            background: #28a745;
            color: white;
        }

        .content-type-indicator.js {
            background: #ffc107;
            color: #333;
        }

        .content-type-indicator.unknown {
            background: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>n8n Helper</h1>
        <p class="subtitle">Napraw b≈Çƒôdne dane JSON i zarzƒÖdzaj workflow n8n w kilka sekund</p>
        
        <div class="info-banner">
            üîí <strong>Przetwarzane lokalnie w przeglƒÖdarce.</strong> Twoje dane nie sƒÖ wysy≈Çane na serwer.
            <span id="autosaveStatus" style="display: none; margin-left: 15px;">üíæ Auto-save w≈ÇƒÖczony</span>
        </div>

        <div class="file-drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
            <p><strong>üìÅ Kliknij lub przeciƒÖgnij plik JSON tutaj</strong></p>
            <p style="font-size: 12px; color: #999;">lub wpisz JSON poni≈ºej</p>
            <input type="file" id="fileInput" class="file-input-hidden" accept=".json,.js,application/json,text/javascript,text/plain">
        </div>

        <div class="input-group">
            <label for="templateSelect">Szablon workflow n8n (opcjonalnie):</label>
            <select id="templateSelect" class="template-select" onchange="loadTemplate()">
                <option value="">-- Wybierz szablon --</option>
                <option value="empty">Pusty workflow</option>
                <option value="webhook">Webhook ‚Üí HTTP Request</option>
                <option value="schedule">Schedule ‚Üí Task</option>
                <option value="manual">Manual Trigger</option>
            </select>
        </div>

        <div class="input-group">
            <label for="jsonInput">
                Workflow JSON (n8n):
                <span id="contentTypeIndicator" class="content-type-indicator" style="display: none;"></span>
            </label>
            <textarea id="jsonInput" placeholder='Wklej tutaj workflow n8n w formacie JSON (skopiuj z n8n i wklej tutaj) lub u≈ºyj szablonu powy≈ºej'></textarea>
        </div>

        <div class="options-row">
            <div class="option-group">
                <label>
                    <input type="checkbox" id="formatCheckbox" checked>
                    <span>Formatuj JSON (pretty print)</span>
                </label>
            </div>
            <div class="option-group">
                <label>
                    <input type="checkbox" id="autoSaveCheckbox" checked>
                    <span>Zapisz lokalnie (auto-save)</span>
                </label>
            </div>
            <div class="option-group">
                <label>
                    <input type="checkbox" id="n8nExportMode" checked>
                    <span>Tryb eksportu n8n (zawsze .json)</span>
                </label>
            </div>
        </div>

        <div id="stats" class="stats" style="display: none;">
            <div class="stat-item"><strong>Rozmiar:</strong> <span id="statSize">-</span></div>
            <div class="stat-item"><strong>Klucze:</strong> <span id="statKeys">-</span></div>
            <div class="stat-item"><strong>Poziomy:</strong> <span id="statDepth">-</span></div>
        </div>

        <div id="n8nInfo" class="n8n-info">
            <h3>üìä Informacje o workflow n8n</h3>
            <div class="n8n-info-item"><strong>Nazwa:</strong> <span id="n8nName">-</span></div>
            <div class="n8n-info-item"><strong>Wƒôz≈Çy:</strong> <span id="n8nNodes">-</span></div>
            <div class="n8n-info-item"><strong>Po≈ÇƒÖczenia:</strong> <span id="n8nConnections">-</span></div>
            <div class="n8n-info-item"><strong>Wersja:</strong> <span id="n8nVersion">-</span></div>
            <div class="n8n-info-item"><strong>Aktywne:</strong> <span id="n8nActive">-</span></div>
        </div>

        <div class="input-group">
            <label for="filenameInput">Nazwa pliku (bez rozszerzenia):</label>
            <input type="text" id="filenameInput" class="filename-input" placeholder="data" value="data">
        </div>

        <div class="button-group" style="flex-wrap: wrap;">
            <button class="btn-validate" onclick="validateContent()">Waliduj JSON</button>
            <button class="btn-fix" onclick="formatOrFix()">üîß Formatuj/Napraw</button>
            <button class="btn-n8n" onclick="validateN8N()">Waliduj n8n</button>
            <button class="btn-n8n" onclick="exportToN8N()" style="background: #ff6d5a;">üì• Eksportuj do n8n</button>
            <button class="btn-copy" onclick="copyToClipboard()">Kopiuj JSON</button>
            <button class="btn-download" onclick="downloadJSON()">Pobierz JSON</button>
            <button class="btn-clear" onclick="clearInput()">Wyczy≈õƒá</button>
        </div>
        
        <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="btn-validate" onclick="minifyJSON()" style="flex: 0 0 auto; padding: 8px 16px; font-size: 13px;">Minifikuj JSON</button>
            <button class="btn-validate" onclick="beautifyJSON()" style="flex: 0 0 auto; padding: 8px 16px; font-size: 13px;">Sformatuj JSON</button>
            <button class="btn-validate" onclick="showStructure()" style="flex: 0 0 auto; padding: 8px 16px; font-size: 13px;">Poka≈º strukturƒô</button>
            <button class="btn-validate" onclick="restoreOriginal()" id="restoreBtn" style="flex: 0 0 auto; padding: 8px 16px; font-size: 13px; display: none;">Przywr√≥ƒá orygina≈Ç</button>
        </div>

        <div id="message" class="message"></div>

        <div class="info">
            <strong>üìñ SZCZEG√ì≈ÅOWA INSTRUKCJA U≈ªYCIA</strong><br><br>
            
            <strong>üéØ SCENARIUSZ 1: Eksport workflow z n8n i import z powrotem</strong><br>
            <strong>Kiedy:</strong> Chcesz wyeksportowaƒá workflow z n8n, edytowaƒá i zaimportowaƒá z powrotem<br>
            <strong>Kroki:</strong><br>
            1. W n8n: Menu ‚Üí Export (skopiuj JSON)<br>
            2. Wklej JSON tutaj (Ctrl/Cmd+V)<br>
            3. <strong>"Waliduj JSON"</strong> - sprawd≈∫ czy jest poprawny<br>
            4. Je≈õli b≈Çƒôdy: <strong>"üîß Formatuj/Napraw"</strong> - automatycznie naprawi<br>
            5. <strong>"üì• Eksportuj do n8n"</strong> - pobierz plik<br>
            6. W n8n: Menu ‚Üí Import from File ‚Üí wybierz pobrany plik<br><br>
            
            <strong>üéØ SCENARIUSZ 2: Edycja istniejƒÖcego workflow</strong><br>
            <strong>Kiedy:</strong> Chcesz zmieniƒá co≈õ w workflow (np. nazwƒô, parametry)<br>
            <strong>Kroki:</strong><br>
            1. Wklej JSON z n8n<br>
            2. Edytuj rƒôcznie w edytorze (np. zmie≈Ñ nazwƒô, parametry)<br>
            3. <strong>"Waliduj JSON"</strong> - sprawd≈∫ czy nie zepsu≈Çe≈õ sk≈Çadni<br>
            4. Je≈õli b≈Çƒôdy: <strong>"üîß Formatuj/Napraw"</strong><br>
            5. <strong>"Waliduj n8n"</strong> - sprawd≈∫ strukturƒô workflow<br>
            6. <strong>"üì• Eksportuj do n8n"</strong> - pobierz<br>
            7. Import w n8n<br><br>
            
            <strong>üéØ SCENARIUSZ 3: Analiza du≈ºego workflow</strong><br>
            <strong>Kiedy:</strong> Chcesz szybko zobaczyƒá strukturƒô bez scrollowania<br>
            <strong>Kroki:</strong><br>
            1. Wklej JSON<br>
            2. <strong>"Poka≈º strukturƒô"</strong> - zobacz tylko klucze i typy<br>
            3. Analizuj strukturƒô<br>
            4. <strong>"Przywr√≥ƒá orygina≈Ç"</strong> - wr√≥ƒá do pe≈Çnego JSON<br>
            5. Edytuj je≈õli potrzeba<br>
            6. Eksportuj<br><br>
            
            <strong>üéØ SCENARIUSZ 4: Naprawa uszkodzonego JSON</strong><br>
            <strong>Kiedy:</strong> Masz JSON z b≈Çƒôdami (komentarze, brakujƒÖce przecinki, itp.)<br>
            <strong>Kroki:</strong><br>
            1. Wklej uszkodzony JSON<br>
            2. <strong>"Waliduj JSON"</strong> - zobacz b≈ÇƒÖd<br>
            3. <strong>"üîß Formatuj/Napraw"</strong> - automatyczna naprawa:<br>
               ‚Ä¢ Usuwa komentarze (// i /* */)<br>
               ‚Ä¢ Naprawia brakujƒÖce przecinki<br>
               ‚Ä¢ Zamienia pojedyncze cudzys≈Çowy na podw√≥jne<br>
               ‚Ä¢ Usuwa trailing commas<br>
               ‚Ä¢ Zamienia undefined/NaN/Infinity na null<br>
            4. Je≈õli nadal b≈Çƒôdy - sprawd≈∫ komunikat z lokalizacjƒÖ<br>
            5. Napraw rƒôcznie w miejscu wskazanym<br>
            6. Powt√≥rz walidacjƒô<br><br>
            
            <strong>üîç KIEDY U≈ªYWAƒÜ JAKICH PRZYCISK√ìW:</strong><br>
            ‚Ä¢ <strong>"Waliduj JSON"</strong> - ZAWSZE przed eksportem, po edycji, gdy widzisz b≈ÇƒÖd<br>
            ‚Ä¢ <strong>"üîß Formatuj/Napraw"</strong> - gdy JSON ma b≈Çƒôdy, po wklejeniu z zewnƒôtrznego ≈∫r√≥d≈Ça<br>
            ‚Ä¢ <strong>"Waliduj n8n"</strong> - przed eksportem do n8n, sprawdza strukturƒô workflow<br>
            ‚Ä¢ <strong>"üì• Eksportuj do n8n"</strong> - gdy chcesz gotowy plik do importu (zawsze formatuje)<br>
            ‚Ä¢ <strong>"Pobierz JSON"</strong> - gdy chcesz kontrolowaƒá formatowanie (respektuje checkbox)<br>
            ‚Ä¢ <strong>"Kopiuj JSON"</strong> - gdy chcesz wkleiƒá gdzie indziej<br>
            ‚Ä¢ <strong>"Sformatuj JSON"</strong> - gdy chcesz ≈Çadnie wy≈õwietliƒá (pretty print)<br>
            ‚Ä¢ <strong>"Minifikuj JSON"</strong> - gdy chcesz zmniejszyƒá rozmiar pliku<br>
            ‚Ä¢ <strong>"Poka≈º strukturƒô"</strong> - gdy chcesz szybko przejrzeƒá du≈ºe workflow<br><br>
            
            <strong>üí° OPCJE - KIEDY W≈ÅƒÑCZYƒÜ/WY≈ÅƒÑCZYƒÜ:</strong><br>
            ‚Ä¢ <strong>"Formatuj JSON"</strong> - ZAWSZE W≈ÅƒÑCZONE (≈Çatwiej czytaƒá i edytowaƒá)<br>
            ‚Ä¢ <strong>"Tryb eksportu n8n"</strong> - ZAWSZE W≈ÅƒÑCZONE (zapewnia .json dla n8n)<br>
            ‚Ä¢ <strong>"Zapisz lokalnie"</strong> - W≈ÅƒÑCZONE je≈õli chcesz auto-zapis (przydatne przy d≈Çugiej edycji)<br><br>
            
            <strong>‚ö° SKR√ìTY KLAWISZOWE:</strong><br>
            ‚Ä¢ Ctrl/Cmd + Enter = szybkie pobranie JSON<br>
            ‚Ä¢ PrzeciƒÖgnij plik .json = automatyczne wczytanie<br><br>
            
            <strong>üõ°Ô∏è BEZPIECZE≈ÉSTWO:</strong><br>
            ‚Ä¢ Wszystkie naprawy sƒÖ bezpieczne - nie zmieniajƒÖ danych, tylko sk≈Çadniƒô<br>
            ‚Ä¢ "Poka≈º strukturƒô" zapisuje orygina≈Ç - mo≈ºesz zawsze przywr√≥ciƒá<br>
            ‚Ä¢ Auto-save zapisuje lokalnie w przeglƒÖdarce (nie wysy≈Ça nigdzie)<br><br>
            
            <strong>üîß Co naprawia funkcja "Formatuj/Napraw":</strong><br>
            ‚Ä¢ Pythonowe warto≈õci: <code>True</code> ‚Üí <code>true</code>, <code>False</code> ‚Üí <code>false</code>, <code>None</code> ‚Üí <code>null</code><br>
            ‚Ä¢ Pojedyncze cudzys≈Çowy: <code>'value'</code> ‚Üí <code>"value"</code><br>
            ‚Ä¢ BrakujƒÖce cudzys≈Çowy przy kluczach: <code>klucz:</code> ‚Üí <code>"klucz":</code><br>
            ‚Ä¢ Komentarze: <code>// komentarz</code> i <code>/* blok */</code><br>
            ‚Ä¢ Trailing commas: <code>["a", "b",]</code> ‚Üí <code>["a", "b"]</code><br>
            ‚Ä¢ BrakujƒÖce przecinki miƒôdzy w≈Ça≈õciwo≈õciami<br>
            ‚Ä¢ JavaScript warto≈õci: <code>undefined</code> ‚Üí <code>null</code>, <code>NaN</code> ‚Üí <code>null</code>, <code>Infinity</code> ‚Üí <code>null</code><br>
            ‚Ä¢ Podw√≥jne przecinki<br>
            ‚Ä¢ BOM (Byte Order Mark)<br><br>
            
            <strong>üîí PRZETWARZANIE LOKALNE:</strong><br>
            Wszystkie operacje wykonywane sƒÖ w Twojej przeglƒÖdarce. ≈ªadne dane nie sƒÖ wysy≈Çane na serwer.
        </div>
    </div>

    <script>
        const jsonInput = document.getElementById('jsonInput');
        const filenameInput = document.getElementById('filenameInput');
        const message = document.getElementById('message');
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const formatCheckbox = document.getElementById('formatCheckbox');
        const autoSaveCheckbox = document.getElementById('autoSaveCheckbox');
        const n8nExportModeCheckbox = document.getElementById('n8nExportMode');
        const stats = document.getElementById('stats');

        // NIE wczytuj zapisanego JSON przy starcie - zawsze zaczynaj z pustym polem
        window.addEventListener('DOMContentLoaded', () => {
            // Wyczy≈õƒá pole przy starcie
            jsonInput.value = '';
            filenameInput.value = 'data';
            updateContentTypeIndicator();
            updateStats();
            updateAutosaveStatus();
        });

        // Funkcja do aktualizacji statusu autosave
        function updateAutosaveStatus() {
            const autosaveStatus = document.getElementById('autosaveStatus');
            if (autoSaveCheckbox.checked) {
                autosaveStatus.style.display = 'inline';
            } else {
                autosaveStatus.style.display = 'none';
            }
        }

        // Aktualizuj status autosave przy zmianie checkboxa
        autoSaveCheckbox.addEventListener('change', () => {
            updateAutosaveStatus();
            if (!autoSaveCheckbox.checked) {
                localStorage.removeItem('jsonEditor_data');
            }
        });

        function showMessage(text, isError = false) {
            message.textContent = text;
            message.className = 'message ' + (isError ? 'error' : 'success');
            setTimeout(() => {
                message.className = 'message';
            }, 5000);
        }

        function updateStats() {
            const content = jsonInput.value.trim();
            if (!content) {
                stats.style.display = 'none';
                updateN8NInfo(null);
                return;
            }

            // Sprawd≈∫ typ zawarto≈õci - statystyki tylko dla JSON
            const detection = detectContentType(content);
            
            if (detection.type !== 'json') {
                // Dla JavaScript lub nieznanego typu - ukryj statystyki
                stats.style.display = 'none';
                updateN8NInfo(null);
                return;
            }

            // Tylko dla JSON - wy≈õwietl statystyki
            try {
                const parsed = JSON.parse(content);
                const size = new Blob([content]).size;
                const keys = countKeys(parsed);
                const depth = getDepth(parsed);

                document.getElementById('statSize').textContent = formatBytes(size);
                document.getElementById('statKeys').textContent = keys;
                document.getElementById('statDepth').textContent = depth;
                stats.style.display = 'flex';
                
                // Aktualizuj informacje n8n je≈õli to workflow
                updateN8NInfo(parsed);
            } catch (e) {
                // Je≈õli nie mo≈ºna sparsowaƒá jako JSON, ukryj statystyki
                stats.style.display = 'none';
                updateN8NInfo(null);
            }
        }

        function updateN8NInfo(workflow) {
            const n8nInfo = document.getElementById('n8nInfo');
            if (!workflow || !isN8NWorkflow(workflow)) {
                n8nInfo.classList.remove('show');
                return;
            }

            const name = workflow.name || 'Brak nazwy';
            const nodes = workflow.nodes ? workflow.nodes.length : 0;
            const connections = workflow.connections ? Object.keys(workflow.connections).length : 0;
            const version = workflow.version || 'Brak';
            const active = workflow.active !== undefined ? (workflow.active ? 'Tak' : 'Nie') : 'Nieznane';

            document.getElementById('n8nName').textContent = name;
            document.getElementById('n8nNodes').textContent = nodes;
            document.getElementById('n8nConnections').textContent = connections;
            document.getElementById('n8nVersion').textContent = version;
            document.getElementById('n8nActive').textContent = active;
            n8nInfo.classList.add('show');
        }

        function isN8NWorkflow(obj) {
            // Podstawowa walidacja struktury n8n workflow
            return obj && (
                (obj.nodes && Array.isArray(obj.nodes)) ||
                (obj.connections && typeof obj.connections === 'object') ||
                obj.name !== undefined
            );
        }

        function validateN8N() {
            const jsonText = jsonInput.value.trim();
            
            if (!jsonText) {
                showMessage('Pole JSON jest puste', true);
                jsonInput.classList.add('error');
                return false;
            }

            let parsed;
            try {
                parsed = JSON.parse(jsonText);
            } catch (e) {
                showMessage('B≈ÇƒÖd JSON: ' + e.message, true);
                jsonInput.classList.add('error');
                return false;
            }

            // Walidacja struktury n8n
            const errors = [];
            const warnings = [];

            if (!isN8NWorkflow(parsed)) {
                errors.push('To nie wyglƒÖda na workflow n8n');
            }

            if (!parsed.nodes || !Array.isArray(parsed.nodes)) {
                errors.push('Brak lub nieprawid≈Çowa tablica "nodes"');
            } else {
                if (parsed.nodes.length === 0) {
                    warnings.push('Workflow nie ma ≈ºadnych wƒôz≈Ç√≥w');
                }
                
                // Sprawd≈∫ podstawowe w≈Ça≈õciwo≈õci wƒôz≈Ç√≥w
                parsed.nodes.forEach((node, index) => {
                    if (!node.name) {
                        warnings.push(`Wƒôze≈Ç ${index + 1} nie ma nazwy`);
                    }
                    if (!node.type) {
                        errors.push(`Wƒôze≈Ç ${index + 1} nie ma typu`);
                    }
                });
            }

            if (!parsed.name) {
                warnings.push('Workflow nie ma nazwy');
            }

            if (errors.length > 0) {
                showMessage('‚ùå B≈Çƒôdy n8n: ' + errors.join(', '), true);
                jsonInput.classList.add('error');
                return false;
            }

            if (warnings.length > 0) {
                showMessage('‚ö†Ô∏è Ostrze≈ºenia: ' + warnings.join(', ') + ' | ‚úì Struktura workflow jest poprawna');
            } else {
                showMessage('‚úì Workflow n8n jest poprawny!');
            }
            
            jsonInput.classList.remove('error');
            updateN8NInfo(parsed);
            return true;
        }

        function loadTemplate() {
            const templateSelect = document.getElementById('templateSelect');
            const template = templateSelect.value;
            
            if (!template) return;

            let workflow = {};

            switch(template) {
                case 'empty':
                    workflow = {
                        name: 'Nowy Workflow',
                        nodes: [],
                        connections: {},
                        active: false,
                        settings: {},
                        staticData: null,
                        tags: []
                    };
                    break;

                case 'webhook':
                    workflow = {
                        name: 'Webhook ‚Üí HTTP Request',
                        nodes: [
                            {
                                parameters: {},
                                id: 'webhook-node',
                                name: 'Webhook',
                                type: 'n8n-nodes-base.webhook',
                                typeVersion: 1,
                                position: [250, 300]
                            },
                            {
                                parameters: {
                                    url: 'https://example.com/api',
                                    method: 'GET'
                                },
                                id: 'http-node',
                                name: 'HTTP Request',
                                type: 'n8n-nodes-base.httpRequest',
                                typeVersion: 1,
                                position: [450, 300]
                            }
                        ],
                        connections: {
                            'Webhook': {
                                main: [[{ node: 'HTTP Request', type: 'main', index: 0 }]]
                            }
                        },
                        active: false,
                        settings: {},
                        staticData: null,
                        tags: []
                    };
                    break;

                case 'schedule':
                    workflow = {
                        name: 'Schedule ‚Üí Task',
                        nodes: [
                            {
                                parameters: {
                                    rule: {
                                        interval: [{ field: 'hours', hoursInterval: 1 }]
                                    }
                                },
                                id: 'schedule-node',
                                name: 'Schedule',
                                type: 'n8n-nodes-base.scheduleTrigger',
                                typeVersion: 1,
                                position: [250, 300]
                            },
                            {
                                parameters: {},
                                id: 'task-node',
                                name: 'Task',
                                type: 'n8n-nodes-base.noOp',
                                typeVersion: 1,
                                position: [450, 300]
                            }
                        ],
                        connections: {
                            'Schedule': {
                                main: [[{ node: 'Task', type: 'main', index: 0 }]]
                            }
                        },
                        active: false,
                        settings: {},
                        staticData: null,
                        tags: []
                    };
                    break;

                case 'manual':
                    workflow = {
                        name: 'Manual Trigger',
                        nodes: [
                            {
                                parameters: {},
                                id: 'manual-node',
                                name: 'Manual Trigger',
                                type: 'n8n-nodes-base.manualTrigger',
                                typeVersion: 1,
                                position: [250, 300]
                            }
                        ],
                        connections: {},
                        active: false,
                        settings: {},
                        staticData: null,
                        tags: []
                    };
                    break;
            }

            jsonInput.value = JSON.stringify(workflow, null, 2);
            updateStats();
            saveToLocalStorage();
            templateSelect.value = '';
            showMessage('‚úì Szablon za≈Çadowany!');
        }

        function countKeys(obj, count = 0) {
            if (typeof obj !== 'object' || obj === null) return count;
            if (Array.isArray(obj)) {
                return obj.reduce((acc, item) => acc + countKeys(item, 0), count);
            }
            count += Object.keys(obj).length;
            for (let key in obj) {
                count = countKeys(obj[key], count);
            }
            return count;
        }

        function getDepth(obj, current = 0) {
            if (typeof obj !== 'object' || obj === null) return current;
            if (Array.isArray(obj)) {
                if (obj.length === 0) return current;
                return Math.max(...obj.map(item => getDepth(item, current + 1)));
            }
            const keys = Object.keys(obj);
            if (keys.length === 0) return current;
            return Math.max(...keys.map(key => getDepth(obj[key], current + 1)));
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function saveToLocalStorage() {
            if (autoSaveCheckbox.checked) {
                localStorage.setItem('jsonEditor_data', jsonInput.value);
            }
        }

        // Centralny system wykrywania typu zawarto≈õci
        function detectContentType(text) {
            if (!text || !text.trim()) {
                return { type: 'unknown', confidence: 0 };
            }

            const trimmed = text.trim();
            
            // PRIORYTET 1: Najpierw spr√≥buj sparsowaƒá jako JSON
            // Je≈õli JSON.parse() siƒô powiedzie, to ZAWSZE jest JSON (nawet je≈õli zawiera wzorce JS w stringach)
            try {
                JSON.parse(trimmed);
                // Je≈õli parsowanie siƒô powiod≈Ço, to jest JSON - nie sprawdzaj wzorc√≥w JS
                // bo mogƒÖ byƒá w stringach (np. "items.length" w n8n workflow)
                return { type: 'json', confidence: 1.0 };
            } catch (e) {
                // Nie jest poprawnym JSON - sprawd≈∫ czy to JavaScript
            }

            // PRIORYTET 2: Wykryj kod JavaScript (tylko je≈õli nie jest poprawnym JSON)
            const jsPatterns = [
                /^\s*(var|let|const|function|if|for|while|return|class|export|import)\s+/m,
                /;\s*$/m,
                /=>\s*{?/m,
                /\$node\[/m,
                /items\.length/m,
                /continue\s*;/m,
                /break\s*;/m,
                /\.indexOf\(/m,
                /\.push\(/m,
                /\.map\(/m,
                /\.filter\(/m
            ];
            
            // Je≈õli nie zaczyna siƒô od { lub [, prawdopodobnie JS
            if (!trimmed.startsWith('{') && !trimmed.startsWith('[')) {
                const jsMatches = jsPatterns.filter(pattern => pattern.test(trimmed)).length;
                // Je≈õli znajdzie wzorce JS, to JS
                if (jsMatches >= 1) {
                    return { type: 'js', confidence: 0.9 };
                }
                // Je≈õli nie ma wzorc√≥w i nie zaczyna siƒô od { lub [, to mo≈ºe byƒá JS lub tekst
                return { type: 'unknown', confidence: 0.4 };
            }
            
            // Je≈õli zaczyna siƒô od { lub [ ale nie parsuje siƒô jako JSON, sprawd≈∫ wzorce JS
            const jsMatches = jsPatterns.filter(pattern => pattern.test(trimmed)).length;
            if (jsMatches >= 3) {
                return { type: 'js', confidence: 0.8 };
            }

            // Nieznany typ
            return { type: 'unknown', confidence: 0.5 };
        }

        function updateContentTypeIndicator() {
            const text = jsonInput.value.trim();
            const indicator = document.getElementById('contentTypeIndicator');
            
            if (!text) {
                indicator.style.display = 'none';
                return;
            }

            const detection = detectContentType(text);
            indicator.style.display = 'inline-block';
            indicator.className = 'content-type-indicator ' + detection.type;
            
            const labels = {
                'json': 'JSON',
                'js': 'JavaScript',
                'unknown': 'Nieznany'
            };
            
            indicator.textContent = labels[detection.type] || 'Nieznany';
        }

        function formatJavaScript(code) {
            // Zachowaj oryginalne wciƒôcia - tylko normalizuj bia≈Çe znaki i usu≈Ñ zbƒôdne puste linie
            const lines = code.split('\n');
            const formatted = [];
            let lastNonEmpty = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Pomi≈Ñ nadmiarowe puste linie (max 2 z rzƒôdu)
                if (!trimmed) {
                    if (lastNonEmpty >= 0 && i - lastNonEmpty <= 2) {
                        formatted.push('');
                    }
                    continue;
                }
                
                formatted.push(line); // Zachowaj oryginalne wciƒôcia
                lastNonEmpty = i;
            }
            
            // Usu≈Ñ puste linie na ko≈Ñcu
            while (formatted.length > 0 && !formatted[formatted.length - 1].trim()) {
                formatted.pop();
            }
            
            return formatted.join('\n');
        }

        function formatOrFix() {
            const content = jsonInput.value.trim();
            
            if (!content) {
                showMessage('Pole jest puste', true);
                return;
            }

            // NAJPIERW: Spr√≥buj sparsowaƒá jako JSON (priorytet dla JSON)
            try {
                JSON.parse(content);
                // Je≈õli parsuje siƒô jako JSON, u≈ºyj fixJSON
                fixJSON(content);
                return;
            } catch (jsonError) {
                // Nie jest poprawnym JSON - sprawd≈∫ typ
                const detection = detectContentType(content);
                
                // Obs≈Çuga JavaScript
                if (detection.type === 'js') {
                    try {
                        const formatted = formatJavaScript(content);
                        jsonInput.value = formatted;
                        updateContentTypeIndicator();
                        saveToLocalStorage();
                        showMessage('‚úì Kod JavaScript zosta≈Ç sformatowany!');
                        jsonInput.classList.remove('error');
                    } catch (e) {
                        showMessage('‚ö†Ô∏è Nie uda≈Ço siƒô sformatowaƒá kodu JavaScript: ' + e.message, true);
                    }
                    return;
                }

                // Nieznany typ - spr√≥buj naprawiƒá jako JSON
                showMessage('‚ö†Ô∏è Nie rozpoznano typu zawarto≈õci. Pr√≥bujƒô naprawiƒá jako JSON...', false);
                fixJSON(content);
            }
        }

        function fixJSON(jsonText) {
            const fixes = [];
            let fixed = jsonText;
            const originalLength = fixed.length;

            // NAJPIERW: Sprawd≈∫ czy JSON jest ju≈º poprawny - je≈õli tak, tylko sformatuj
            try {
                const alreadyParsed = JSON.parse(fixed);
                // JSON jest poprawny! Tylko sformatuj
                fixed = formatCheckbox.checked 
                    ? JSON.stringify(alreadyParsed, null, 2)
                    : JSON.stringify(alreadyParsed);
                
                jsonInput.value = fixed;
                jsonInput.classList.remove('error');
                updateContentTypeIndicator();
                updateStats();
                saveToLocalStorage();
                
                showMessage('‚úì JSON by≈Ç ju≈º poprawny - sformatowano');
                return; // Sukces - nie trzeba naprawiaƒá
            } catch (e) {
                // JSON ma b≈Çƒôdy - kontynuuj naprawƒô
            }

            // 1. Usu≈Ñ BOM (Byte Order Mark)
            if (fixed.length > 0 && fixed.charCodeAt(0) === 0xFEFF) {
                fixed = fixed.slice(1);
                fixes.push('Usuniƒôto BOM');
            }

            // 2. Usu≈Ñ komentarze jednoliniowe (//) - TYLKO poza stringami
            const beforeComments = fixed;
            let inString = false;
            let escapeNext = false;
            let stringChar = '';
            let result = '';
            
            for (let i = 0; i < fixed.length; i++) {
                const char = fixed[i];
                
                if (escapeNext) {
                    result += char;
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escapeNext = true;
                    continue;
                }
                
                if ((char === '"' || char === "'") && !inString) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (char === stringChar && inString) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    // W stringu - kopiuj wszystko
                    result += char;
                    continue;
                }
                
                // Poza stringiem - sprawd≈∫ komentarze
                if (char === '/' && i + 1 < fixed.length) {
                    if (fixed[i + 1] === '/') {
                        // Komentarz jednoliniowy - usu≈Ñ do ko≈Ñca linii
                        while (i < fixed.length && fixed[i] !== '\n') {
                            i++;
                        }
                        if (i < fixed.length) {
                            result += '\n';
                        }
                        continue;
                    }
                    if (fixed[i + 1] === '*') {
                        // Komentarz wieloliniowy - usu≈Ñ do */
                        i += 2;
                        while (i + 1 < fixed.length) {
                            if (fixed[i] === '*' && fixed[i + 1] === '/') {
                                i += 2;
                                break;
                            }
                            i++;
                        }
                        continue;
                    }
                }
                
                result += char;
            }
            
            if (result !== beforeComments) {
                fixes.push('Usuniƒôto komentarze');
            }
            fixed = result;

            // 3. Zamie≈Ñ pojedyncze cudzys≈Çowy na podw√≥jne TYLKO w kluczach (poza stringami)
            // U≈ºywamy prostszego podej≈õcia - tylko dla kluczy przed dwukropkiem
            const beforeQuotes = fixed;
            fixed = fixed.replace(/([{,]\s*)'([^']+)'(\s*:)/g, '$1"$2"$3');
            if (fixed !== beforeQuotes) {
                fixes.push('Zamieniono cudzys≈Çowy w kluczach');
            }

            // 4. Napraw brakujƒÖce cudzys≈Çowy w kluczach (tylko identyfikatory, poza stringami)
            const beforeKeys = fixed;
            // Bardzo ostro≈ºny regex - tylko identyfikatory przed dwukropkiem, poza stringami
            fixed = fixed.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)(\s*:)/g, '$1"$2"$3');
            if (fixed !== beforeKeys) {
                fixes.push('Dodano cudzys≈Çowy w kluczach');
            }

            // 5. Usu≈Ñ przecinki na ko≈Ñcu (trailing commas) - TYLKO poza stringami
            const beforeTrailing = fixed;
            inString = false;
            escapeNext = false;
            stringChar = '';
            result = '';
            
            for (let i = 0; i < fixed.length; i++) {
                const char = fixed[i];
                
                if (escapeNext) {
                    result += char;
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escapeNext = true;
                    continue;
                }
                
                if ((char === '"' || char === "'") && !inString) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (char === stringChar && inString) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                // Poza stringiem - usu≈Ñ trailing commas
                if (char === ',' && i + 1 < fixed.length) {
                    let j = i + 1;
                    // Pomi≈Ñ bia≈Çe znaki
                    while (j < fixed.length && /\s/.test(fixed[j])) {
                        j++;
                    }
                    if (j < fixed.length && (fixed[j] === '}' || fixed[j] === ']')) {
                        // Trailing comma - pomi≈Ñ
                        i = j - 1;
                        continue;
                    }
                }
                
                result += char;
            }
            
            if (result !== beforeTrailing) {
                fixes.push('Usuniƒôto przecinki na ko≈Ñcu');
            }
            fixed = result;

            // 6. Zamie≈Ñ niepoprawne warto≈õci JavaScript na JSON (TYLKO poza stringami)
            const beforeUndefined = fixed;
            inString = false;
            escapeNext = false;
            stringChar = '';
            result = '';
            
            for (let i = 0; i < fixed.length; i++) {
                const char = fixed[i];
                
                if (escapeNext) {
                    result += char;
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escapeNext = true;
                    continue;
                }
                
                if ((char === '"' || char === "'") && !inString) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (char === stringChar && inString) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                // Poza stringiem - zamie≈Ñ undefined/NaN/Infinity
                if (char === 'u' && fixed.substring(i, i + 9) === 'undefined') {
                    // Sprawd≈∫ kontekst - czy to warto≈õƒá (po dwukropku)
                    let checkBack = i - 1;
                    while (checkBack >= 0 && /\s/.test(fixed[checkBack])) {
                        checkBack--;
                    }
                    if (checkBack >= 0 && fixed[checkBack] === ':') {
                        result += 'null';
                        i += 8; // 'undefined'.length - 1
                        continue;
                    }
                }
                
                if (char === 'N' && fixed.substring(i, i + 3) === 'NaN') {
                    let checkBack = i - 1;
                    while (checkBack >= 0 && /\s/.test(fixed[checkBack])) {
                        checkBack--;
                    }
                    if (checkBack >= 0 && fixed[checkBack] === ':') {
                        result += 'null';
                        i += 2;
                        continue;
                    }
                }
                
                if (char === 'I' && fixed.substring(i, i + 8) === 'Infinity') {
                    let checkBack = i - 1;
                    while (checkBack >= 0 && /\s/.test(fixed[checkBack])) {
                        checkBack--;
                    }
                    if (checkBack >= 0 && fixed[checkBack] === ':') {
                        result += 'null';
                        i += 7;
                        continue;
                    }
                }
                
                result += char;
            }
            
            if (result !== beforeUndefined) {
                fixes.push('Zamieniono niepoprawne warto≈õci na null');
            }
            fixed = result;

            // 7. Napraw podw√≥jne przecinki (TYLKO poza stringami)
            const beforeDoubleCommas = fixed;
            inString = false;
            escapeNext = false;
            stringChar = '';
            result = '';
            
            for (let i = 0; i < fixed.length; i++) {
                const char = fixed[i];
                
                if (escapeNext) {
                    result += char;
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escapeNext = true;
                    continue;
                }
                
                if ((char === '"' || char === "'") && !inString) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (char === stringChar && inString) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                // Poza stringiem - usu≈Ñ podw√≥jne przecinki
                if (char === ',' && i + 1 < fixed.length) {
                    let j = i + 1;
                    while (j < fixed.length && /\s/.test(fixed[j])) {
                        j++;
                    }
                    if (j < fixed.length && fixed[j] === ',') {
                        // Podw√≥jny przecinek - pomi≈Ñ pierwszy
                        continue;
                    }
                }
                
                result += char;
            }
            
            if (result !== beforeDoubleCommas) {
                fixes.push('Usuniƒôto podw√≥jne przecinki');
            }
            fixed = result;

            // 8. Usu≈Ñ zbƒôdne bia≈Çe znaki na poczƒÖtku/ko≈Ñcu
            fixed = fixed.trim();

            // 9. Sprawd≈∫ czy nie zepsu≈Ço siƒô zbyt du≈ºo (zabezpieczenie)
            if (Math.abs(fixed.length - originalLength) > originalLength * 0.5) {
                throw new Error('Naprawa spowodowa≈Ça zbyt du≈ºe zmiany - mo≈ºliwe uszkodzenie danych');
            }

            // Spr√≥buj sparsowaƒá naprawiony JSON
            let parsed;
            try {
                parsed = JSON.parse(fixed);
                
                // Formatuj je≈õli checkbox jest zaznaczony
                if (formatCheckbox.checked) {
                    fixed = JSON.stringify(parsed, null, 2);
                } else {
                    fixed = JSON.stringify(parsed);
                }

                jsonInput.value = fixed;
                jsonInput.classList.remove('error');
                updateContentTypeIndicator();
                updateStats();
                saveToLocalStorage();

                if (fixes.length > 0) {
                    showMessage('‚úì Naprawiono: ' + fixes.join(', '));
                } else {
                    showMessage('‚úì JSON by≈Ç ju≈º poprawny - sformatowano');
                }
                return; // Sukces!
            } catch (e) {
                // Je≈õli nadal nie dzia≈Ça, spr√≥buj bardziej agresywnych napraw (ale bezpiecznie - tylko poza stringami)
                try {
                    let aggressiveFixed = fixed;
                    
                    // KROK 1: Usu≈Ñ trailing commas i napraw undefined (ju≈º zrobione wcze≈õniej, ale powt√≥rzmy)
                    let inString = false;
                    let escapeNext = false;
                    let stringChar = '';
                    let result = '';
                    
                    for (let i = 0; i < aggressiveFixed.length; i++) {
                        const char = aggressiveFixed[i];
                        
                        if (escapeNext) {
                            result += char;
                            escapeNext = false;
                            continue;
                        }
                        
                        if (char === '\\') {
                            result += char;
                            escapeNext = true;
                            continue;
                        }
                        
                        if ((char === '"' || char === "'") && !inString) {
                            inString = true;
                            stringChar = char;
                            result += char;
                            continue;
                        }
                        
                        if (char === stringChar && inString) {
                            inString = false;
                            stringChar = '';
                            result += char;
                            continue;
                        }
                        
                        if (inString) {
                            result += char;
                            continue;
                        }
                        
                        // Poza stringiem - agresywne naprawy
                        // Trailing commas
                        if (char === ',' && i + 1 < aggressiveFixed.length) {
                            let j = i + 1;
                            while (j < aggressiveFixed.length && /\s/.test(aggressiveFixed[j])) {
                                j++;
                            }
                            if (j < aggressiveFixed.length && (aggressiveFixed[j] === '}' || aggressiveFixed[j] === ']')) {
                                continue; // Pomi≈Ñ trailing comma
                            }
                        }
                        
                        // undefined/NaN/Infinity
                        if (char === 'u' && aggressiveFixed.substring(i, i + 9) === 'undefined') {
                            let checkBack = i - 1;
                            while (checkBack >= 0 && /\s/.test(aggressiveFixed[checkBack])) {
                                checkBack--;
                            }
                            if (checkBack >= 0 && aggressiveFixed[checkBack] === ':') {
                                result += 'null';
                                i += 8;
                                continue;
                            }
                        }
                        
                        if (char === 'N' && aggressiveFixed.substring(i, i + 3) === 'NaN') {
                            let checkBack = i - 1;
                            while (checkBack >= 0 && /\s/.test(aggressiveFixed[checkBack])) {
                                checkBack--;
                            }
                            if (checkBack >= 0 && aggressiveFixed[checkBack] === ':') {
                                result += 'null';
                                i += 2;
                                continue;
                            }
                        }
                        
                        if (char === 'I' && aggressiveFixed.substring(i, i + 8) === 'Infinity') {
                            let checkBack = i - 1;
                            while (checkBack >= 0 && /\s/.test(aggressiveFixed[checkBack])) {
                                checkBack--;
                            }
                            if (checkBack >= 0 && aggressiveFixed[checkBack] === ':') {
                                result += 'null';
                                i += 7;
                                continue;
                            }
                        }
                        
                        result += char;
                    }
                    
                    aggressiveFixed = result;
                    
                    // KROK 2: Napraw brakujƒÖce przecinki - parsuj znak po znaku (najbezpieczniejsze)
                    const beforeCommas = aggressiveFixed;
                    inString = false;
                    escapeNext = false;
                    stringChar = '';
                    result = '';
                    let lastValueEnd = -1; // Pozycja ko≈Ñca ostatniej warto≈õci
                    let expectingComma = false; // Czy oczekujemy przecinka
                    
                    for (let i = 0; i < aggressiveFixed.length; i++) {
                        const char = aggressiveFixed[i];
                        
                        if (escapeNext) {
                            result += char;
                            escapeNext = false;
                            continue;
                        }
                        
                        if (char === '\\') {
                            result += char;
                            escapeNext = true;
                            continue;
                        }
                        
                        if ((char === '"' || char === "'") && !inString) {
                            // Sprawd≈∫ czy przed tym cudzys≈Çowem by≈Ça warto≈õƒá bez przecinka
                            // ALE TYLKO je≈õli jeste≈õmy na poziomie w≈Ça≈õciwo≈õci obiektu (nie w zagnie≈ºd≈ºeniu)
                            if (expectingComma && lastValueEnd >= 0) {
                                // Sprawd≈∫ czy miƒôdzy ostatniƒÖ warto≈õciƒÖ a tym cudzys≈Çowem sƒÖ tylko bia≈Çe znaki
                                let between = aggressiveFixed.substring(lastValueEnd + 1, i);
                                if (/^\s*$/.test(between)) {
                                    // Sprawd≈∫ czy to nowa w≈Ça≈õciwo≈õƒá (cudzys≈Ç√≥w, potem dwukropek)
                                    // WA≈ªNE: Sprawd≈∫ czy nie jeste≈õmy w zagnie≈ºd≈ºonym obiekcie/tablicy
                                    let depth = 0;
                                    for (let k = 0; k < i; k++) {
                                        if (aggressiveFixed[k] === '{' || aggressiveFixed[k] === '[') depth++;
                                        if (aggressiveFixed[k] === '}' || aggressiveFixed[k] === ']') depth--;
                                    }
                                    
                                    // Tylko je≈õli jeste≈õmy na poziomie g≈Ç√≥wnym lub w obiekcie (depth >= 0)
                                    if (depth >= 0) {
                                        let checkForward = i + 1;
                                        while (checkForward < aggressiveFixed.length && aggressiveFixed[checkForward] !== '"' && aggressiveFixed[checkForward] !== ':') {
                                            checkForward++;
                                        }
                                        if (checkForward < aggressiveFixed.length && aggressiveFixed[checkForward] === ':') {
                                            // To nowa w≈Ça≈õciwo≈õƒá! Dodaj przecinek przed bia≈Çymi znakami
                                            result += ',';
                                            if (!fixes.includes('Dodano brakujƒÖcy przecinek')) {
                                                fixes.push('Dodano brakujƒÖcy przecinek');
                                            }
                                            expectingComma = false;
                                        }
                                    }
                                }
                            }
                            
                            inString = true;
                            stringChar = char;
                            result += char;
                            continue;
                        }
                        
                        if (char === stringChar && inString) {
                            inString = false;
                            stringChar = '';
                            result += char;
                            lastValueEnd = i;
                            expectingComma = true; // Po stringu oczekujemy przecinka lub zamkniƒôcia
                            continue;
                        }
                        
                        if (inString) {
                            result += char;
                            continue;
                        }
                        
                        // Poza stringiem
                        if (char === '{' || char === '[') {
                            result += char;
                            expectingComma = false;
                            lastValueEnd = -1;
                            continue;
                        }
                        
                        if (char === '}' || char === ']') {
                            result += char;
                            // Po zamkniƒôciu obiektu/tablicy nie oczekujemy przecinka (mo≈ºe byƒá ostatnia w≈Ça≈õciwo≈õƒá)
                            expectingComma = false;
                            lastValueEnd = -1;
                            continue;
                        }
                        
                        if (char === ':') {
                            result += char;
                            expectingComma = false;
                            lastValueEnd = -1;
                            continue;
                        }
                        
                        if (char === ',') {
                            result += char;
                            expectingComma = false;
                            lastValueEnd = -1;
                            continue;
                        }
                        
                        // Je≈õli oczekujemy przecinka i napotkali≈õmy co≈õ innego ni≈º bia≈Çe znaki
                        if (expectingComma && !/\s/.test(char) && char !== '}' && char !== ']') {
                            // Sprawd≈∫ czy to nowa w≈Ça≈õciwo≈õƒá (cudzys≈Ç√≥w, potem dwukropek)
                            if (char === '"') {
                                let checkForward = i + 1;
                                while (checkForward < aggressiveFixed.length && aggressiveFixed[checkForward] !== '"' && aggressiveFixed[checkForward] !== ':') {
                                    checkForward++;
                                }
                                if (checkForward < aggressiveFixed.length && aggressiveFixed[checkForward] === ':') {
                                    // To nowa w≈Ça≈õciwo≈õƒá! Dodaj przecinek przed bia≈Çymi znakami
                                    // Znajd≈∫ poczƒÖtek bia≈Çych znak√≥w przed tym cudzys≈Çowem
                                    let whitespaceStart = i - 1;
                                    while (whitespaceStart >= 0 && /\s/.test(aggressiveFixed[whitespaceStart])) {
                                        whitespaceStart--;
                                    }
                                    // Dodaj przecinek
                                    result += ',';
                                    if (!fixes.includes('Dodano brakujƒÖcy przecinek')) {
                                        fixes.push('Dodano brakujƒÖcy przecinek');
                                    }
                                    expectingComma = false;
                                }
                            }
                        }
                        
                        // Sprawd≈∫ czy to true/false/null
                        if (char === 't' && aggressiveFixed.substring(i, i + 4) === 'true') {
                            result += 'true';
                            i += 3;
                            lastValueEnd = i;
                            expectingComma = true;
                            continue;
                        }
                        
                        if (char === 'f' && aggressiveFixed.substring(i, i + 5) === 'false') {
                            result += 'false';
                            i += 4;
                            lastValueEnd = i;
                            expectingComma = true;
                            continue;
                        }
                        
                        if (char === 'n' && aggressiveFixed.substring(i, i + 4) === 'null') {
                            result += 'null';
                            i += 3;
                            lastValueEnd = i;
                            expectingComma = true;
                            continue;
                        }
                        
                        // Sprawd≈∫ czy to liczba
                        if (/\d/.test(char) || char === '-' || char === '.') {
                            let numEnd = i;
                            let numStr = '';
                            while (numEnd < aggressiveFixed.length) {
                                const testChar = aggressiveFixed[numEnd];
                                if (testChar === ',' || testChar === '}' || testChar === ']' || 
                                    (/\s/.test(testChar) && numStr.length > 0) ||
                                    testChar === ':' || testChar === '"') {
                                    break;
                                }
                                numStr += testChar;
                                numEnd++;
                            }
                            
                            // Sprawd≈∫ czy to poprawna liczba
                            if (/^-?\d+\.?\d*$/.test(numStr.trim())) {
                                result += numStr;
                                i = numEnd - 1;
                                lastValueEnd = i;
                                expectingComma = true;
                                continue;
                            }
                        }
                        
                        result += char;
                    }
                    
                    aggressiveFixed = result;
                    
                    // Spr√≥buj sparsowaƒá ponownie
                    if (aggressiveFixed.trim().startsWith('{') || aggressiveFixed.trim().startsWith('[')) {
                        parsed = JSON.parse(aggressiveFixed);
                        fixed = formatCheckbox.checked 
                            ? JSON.stringify(parsed, null, 2)
                            : JSON.stringify(parsed);
                        
                        jsonInput.value = fixed;
                        jsonInput.classList.remove('error');
                        updateContentTypeIndicator();
                        updateStats();
                        saveToLocalStorage();
                        showMessage('‚úì Naprawiono z u≈ºyciem zaawansowanych metod');
                        return; // Sukces po agresywnych naprawach
                    } else {
                        throw new Error('Struktura nie wyglƒÖda na JSON');
                    }
                } catch (e2) {
                    // Ostatnia pr√≥ba - poka≈º szczeg√≥≈Çowy b≈ÇƒÖd z lokalizacjƒÖ
                    const errorMsg = e2.message;
                    let detailedMsg = '‚ùå Nie uda≈Ço siƒô automatycznie naprawiƒá JSON.\n\n';
                    detailedMsg += 'B≈ÇƒÖd: ' + errorMsg + '\n\n';
                    
                    // Spr√≥buj wyciƒÖgnƒÖƒá numer linii z b≈Çƒôdu
                    const lineMatch = errorMsg.match(/line (\d+)/i);
                    const posMatch = errorMsg.match(/position (\d+)/i);
                    
                    if (lineMatch) {
                        const lineNum = parseInt(lineMatch[1]);
                        const lines = fixed.split('\n');
                        if (lines[lineNum - 1]) {
                            detailedMsg += `Linia ${lineNum}: ${lines[lineNum - 1].trim()}\n\n`;
                        }
                    } else if (posMatch) {
                        const pos = parseInt(posMatch[1]);
                        const before = fixed.substring(0, Math.min(pos, fixed.length));
                        const after = fixed.substring(pos, Math.min(pos + 50, fixed.length));
                        const lineNum = before.split('\n').length;
                        detailedMsg += `Pozycja ${pos} (linia ~${lineNum}):\n`;
                        detailedMsg += `...${before.slice(-30)}[B≈ÅƒÑD]${after.slice(0, 30)}...\n\n`;
                    }
                    
                    detailedMsg += 'üí° Wskaz√≥wki do rƒôcznej naprawy:\n';
                    detailedMsg += '‚Ä¢ Sprawd≈∫ czy wszystkie przecinki sƒÖ na miejscu (szczeg√≥lnie miƒôdzy w≈Ça≈õciwo≈õciami)\n';
                    detailedMsg += '‚Ä¢ Sprawd≈∫ czy wszystkie cudzys≈Çowy sƒÖ zamkniƒôte\n';
                    detailedMsg += '‚Ä¢ Sprawd≈∫ czy nie ma komentarzy w JSON (// lub /* */)\n';
                    detailedMsg += '‚Ä¢ Sprawd≈∫ czy nie ma undefined, NaN, Infinity\n';
                    detailedMsg += '‚Ä¢ Sprawd≈∫ czy w stringach nie ma niepoprawnych escape\'√≥w\n';
                    detailedMsg += '‚Ä¢ U≈ºyj "Waliduj JSON" aby zobaczyƒá dok≈Çadny b≈ÇƒÖd\n';
                    detailedMsg += '\nüí° Czƒôsty b≈ÇƒÖd: Brak przecinka miƒôdzy w≈Ça≈õciwo≈õciami\n';
                    detailedMsg += '   Przyk≈Çad b≈Çƒôdny: "key1": "value1" "key2": "value2"\n';
                    detailedMsg += '   Przyk≈Çad poprawny: "key1": "value1", "key2": "value2"';
                    
                    alert(detailedMsg);
                    showMessage('‚ùå Nie uda≈Ço siƒô automatycznie naprawiƒá JSON. Sprawd≈∫ szczeg√≥≈Çy w oknie dialogowym.', true);
                    jsonInput.classList.add('error');
                }
            }
        }

        function validateContent() {
            const content = jsonInput.value.trim();
            
            if (!content) {
                showMessage('Pole jest puste', true);
                jsonInput.classList.add('error');
                updateContentTypeIndicator();
                return false;
            }

            // NAJPIERW: Spr√≥buj sparsowaƒá jako JSON (priorytet dla JSON)
            try {
                const parsed = JSON.parse(content);
                updateContentTypeIndicator();
                showMessage('‚úì JSON jest poprawny!');
                jsonInput.classList.remove('error');
                updateStats();
                return true;
            } catch (jsonError) {
                // Nie jest poprawnym JSON - sprawd≈∫ typ
                const detection = detectContentType(content);
                updateContentTypeIndicator();

                if (detection.type === 'js') {
                    // Podstawowa walidacja sk≈Çadni JS
                    try {
                        new Function(content);
                        showMessage('‚úì Kod JavaScript wyglƒÖda poprawnie!');
                        jsonInput.classList.remove('error');
                        return true;
                    } catch (e) {
                        showMessage('‚ö†Ô∏è Mo≈ºliwe b≈Çƒôdy w kodzie JavaScript: ' + e.message, true);
                        jsonInput.classList.add('error');
                        return false;
                    }
                }

                // Je≈õli nie JSON i nie JS, poka≈º b≈ÇƒÖd JSON
                showMessage('B≈ÇƒÖd JSON: ' + jsonError.message, true);
                jsonInput.classList.add('error');
                updateStats();
                return false;
            }
        }

        function exportToN8N() {
            const content = jsonInput.value.trim();
            
            if (!content) {
                showMessage('Pole jest puste', true);
                jsonInput.classList.add('error');
                return;
            }

            let parsedJSON;
            try {
                parsedJSON = JSON.parse(content);
            } catch (e) {
                showMessage('‚ùå To nie jest poprawny JSON. U≈ºyj "üîß Formatuj/Napraw" aby naprawiƒá b≈Çƒôdy.', true);
                jsonInput.classList.add('error');
                return;
            }

            // Walidacja czy to workflow n8n
            const isN8N = isN8NWorkflow(parsedJSON);
            if (!isN8N) {
                const confirmExport = confirm('‚ö†Ô∏è To nie wyglƒÖda na workflow n8n. Czy na pewno chcesz eksportowaƒá jako JSON?');
                if (!confirmExport) {
                    return;
                }
            } else {
                // Je≈õli to workflow n8n, sprawd≈∫ podstawowe wymagania
                const errors = [];
                if (!parsedJSON.nodes || !Array.isArray(parsedJSON.nodes)) {
                    errors.push('Brak tablicy "nodes"');
                }
                if (errors.length > 0) {
                    const confirmExport = confirm('‚ö†Ô∏è Workflow n8n ma b≈Çƒôdy: ' + errors.join(', ') + '. Czy na pewno chcesz eksportowaƒá?');
                    if (!confirmExport) {
                        return;
                    }
                }
            }

            // Przygotuj workflow do eksportu - zawsze formatuj (pretty print)
            const formattedJSON = JSON.stringify(parsedJSON, null, 2);
            
            // Ustaw nazwƒô pliku na podstawie workflow
            let filename = 'workflow';
            if (parsedJSON.name) {
                filename = parsedJSON.name.replace(/[^a-z0-9_-]/gi, '_');
            } else if (filenameInput.value.trim()) {
                filename = filenameInput.value.trim().replace(/[^a-z0-9_-]/gi, '_');
            }

            // Pobierz jako JSON
            const blob = new Blob([formattedJSON], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage('‚úì Workflow n8n gotowy do importu! Zaimportuj w n8n: Menu ‚Üí Import from File ‚Üí wybierz pobrany plik.');
            jsonInput.classList.remove('error');
        }

        function minifyJSON() {
            const content = jsonInput.value.trim();
            if (!content) {
                showMessage('Pole jest puste', true);
                return;
            }

            try {
                const parsed = JSON.parse(content);
                const minified = JSON.stringify(parsed);
                jsonInput.value = minified;
                updateContentTypeIndicator();
                updateStats();
                saveToLocalStorage();
                // Formatowanie nie zmienia struktury, wiƒôc nie resetujemy orygina≈Çu
                showMessage('‚úì JSON zosta≈Ç zminifikowany (usuniƒôto wszystkie bia≈Çe znaki)!');
                jsonInput.classList.remove('error');
            } catch (e) {
                showMessage('B≈ÇƒÖd JSON: ' + e.message + '. U≈ºyj "üîß Formatuj/Napraw" aby naprawiƒá.', true);
                jsonInput.classList.add('error');
            }
        }

        function beautifyJSON() {
            const content = jsonInput.value.trim();
            if (!content) {
                showMessage('Pole jest puste', true);
                return;
            }

            try {
                const parsed = JSON.parse(content);
                const beautified = JSON.stringify(parsed, null, 2);
                jsonInput.value = beautified;
                updateContentTypeIndicator();
                updateStats();
                saveToLocalStorage();
                // Formatowanie nie zmienia struktury, wiƒôc nie resetujemy orygina≈Çu
                showMessage('‚úì JSON zosta≈Ç sformatowany (pretty print)!');
                jsonInput.classList.remove('error');
            } catch (e) {
                showMessage('B≈ÇƒÖd JSON: ' + e.message + '. U≈ºyj "üîß Formatuj/Napraw" aby naprawiƒá.', true);
                jsonInput.classList.add('error');
            }
        }

        // Zmienna do przechowywania oryginalnego JSON przed pokazaniem struktury
        let originalJSONBeforeStructure = null;

        function showStructure() {
            const content = jsonInput.value.trim();
            if (!content) {
                showMessage('Pole jest puste', true);
                return;
            }

            try {
                const parsed = JSON.parse(content);
                
                // Zapisz oryginalny JSON je≈õli jeszcze nie zapisany
                if (originalJSONBeforeStructure === null) {
                    originalJSONBeforeStructure = content;
                }
                
                // Funkcja do tworzenia struktury (typy warto≈õci, bez danych)
                function getStructure(obj, depth = 0) {
                    if (depth > 10) return '...'; // Zabezpieczenie przed zbyt g≈Çƒôbokim zagnie≈ºd≈ºeniem
                    
                    if (obj === null) return 'null';
                    if (Array.isArray(obj)) {
                        if (obj.length === 0) return '[]';
                        return '[' + getStructure(obj[0], depth + 1) + ', ...] (' + obj.length + ' items)';
                    }
                    if (typeof obj === 'object') {
                        const keys = Object.keys(obj);
                        if (keys.length === 0) return '{}';
                        const structure = {};
                        keys.forEach(key => {
                            const value = obj[key];
                            if (typeof value === 'object' && value !== null) {
                                structure[key] = getStructure(value, depth + 1);
                            } else {
                                structure[key] = typeof value;
                            }
                        });
                        return JSON.stringify(structure, null, 2);
                    }
                    return typeof obj;
                }

                const structure = getStructure(parsed);
                jsonInput.value = structure;
                updateContentTypeIndicator();
                
                // Poka≈º przycisk "Przywr√≥ƒá orygina≈Ç"
                document.getElementById('restoreBtn').style.display = 'inline-block';
                
                showMessage('‚úì Wy≈õwietlono strukturƒô JSON. U≈ºyj "Przywr√≥ƒá orygina≈Ç" aby wr√≥ciƒá do pe≈Çnego JSON.');
                jsonInput.classList.remove('error');
            } catch (e) {
                showMessage('B≈ÇƒÖd JSON: ' + e.message, true);
                jsonInput.classList.add('error');
            }
        }

        function restoreOriginal() {
            if (originalJSONBeforeStructure !== null) {
                jsonInput.value = originalJSONBeforeStructure;
                originalJSONBeforeStructure = null;
                updateContentTypeIndicator();
                updateStats();
                saveToLocalStorage();
                
                // Ukryj przycisk "Przywr√≥ƒá orygina≈Ç"
                document.getElementById('restoreBtn').style.display = 'none';
                
                showMessage('‚úì Przywr√≥cono oryginalny JSON!');
                jsonInput.classList.remove('error');
            } else {
                showMessage('Brak zapisanego orygina≈Çu do przywr√≥cenia', false);
            }
        }

        function downloadJSON() {
            const content = jsonInput.value.trim();
            
            if (!content) {
                showMessage('Pole jest puste', true);
                jsonInput.classList.add('error');
                return;
            }

            // Sprawd≈∫ czy tryb n8n jest w≈ÇƒÖczony
            const n8nExportMode = n8nExportModeCheckbox.checked;

            // NAJWA≈ªNIEJSZE: Je≈õli tryb n8n jest w≈ÇƒÖczony, zawsze pr√≥buj jako JSON
            if (n8nExportMode) {
                let parsedJSON = null;
                try {
                    parsedJSON = JSON.parse(content);
                    
                    // Je≈õli parsuje siƒô jako JSON, zawsze pobierz jako .json
                    const formattedJSON = formatCheckbox.checked 
                        ? JSON.stringify(parsedJSON, null, 2)
                        : JSON.stringify(parsedJSON);
                    
                    let filename = filenameInput.value.trim();
                    if (isN8NWorkflow(parsedJSON) && parsedJSON.name) {
                        filename = parsedJSON.name.replace(/[^a-z0-9_-]/gi, '_');
                    }
                    if (!filename) filename = 'workflow';
                    
                    const blob = new Blob([formattedJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename + '.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showMessage('‚úì Plik JSON zosta≈Ç pobrany! Gotowy do importu w n8n.');
                    jsonInput.classList.remove('error');
                    return;
                } catch (e) {
                    // Je≈õli nie parsuje siƒô jako JSON w trybie n8n, poka≈º b≈ÇƒÖd
                    showMessage('‚ùå To nie jest poprawny JSON. U≈ºyj "Formatuj/Napraw" aby naprawiƒá b≈Çƒôdy lub wy≈ÇƒÖcz "Tryb eksportu n8n".', true);
                    jsonInput.classList.add('error');
                    return;
                }
            }

            // Je≈õli tryb n8n jest wy≈ÇƒÖczony, u≈ºyj standardowej logiki
            let parsedJSON = null;
            let isValidJSON = false;
            try {
                parsedJSON = JSON.parse(content);
                isValidJSON = true;
            } catch (e) {
                // Nie jest poprawnym JSON
            }

            // Je≈õli parsuje siƒô jako JSON, zawsze pobierz jako .json
            if (isValidJSON && parsedJSON !== null) {
                const formattedJSON = formatCheckbox.checked 
                    ? JSON.stringify(parsedJSON, null, 2)
                    : JSON.stringify(parsedJSON);
                
                let filename = filenameInput.value.trim();
                if (isN8NWorkflow(parsedJSON) && parsedJSON.name) {
                    filename = parsedJSON.name.replace(/[^a-z0-9_-]/gi, '_');
                }
                if (!filename) filename = 'data';
                
                const blob = new Blob([formattedJSON], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMessage('‚úì Plik JSON zosta≈Ç pobrany!');
                jsonInput.classList.remove('error');
                return;
            }

            // Je≈õli nie jest poprawnym JSON, sprawd≈∫ typ
            const detection = detectContentType(content);
            
            // Obs≈Çuga JavaScript (tylko gdy tryb n8n wy≈ÇƒÖczony)
            if (detection.type === 'js') {
                let filename = filenameInput.value.trim() || 'code';
                filename = filename.replace(/[^a-z0-9_-]/gi, '_');
                if (!filename) filename = 'code';
                
                const blob = new Blob([content], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.js';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showMessage('‚úì Kod JavaScript zosta≈Ç pobrany jako plik .js!');
                jsonInput.classList.remove('error');
                return;
            }

            // Nieznany typ - spr√≥buj jako tekst
            let filename = filenameInput.value.trim() || 'content';
            filename = filename.replace(/[^a-z0-9_-]/gi, '_');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('‚úì Zawarto≈õƒá zosta≈Ça pobrana jako plik tekstowy!');
        }

        function copyToClipboard() {
            const content = jsonInput.value.trim();
            
            if (!content) {
                showMessage('Pole jest puste', true);
                return;
            }

            let textToCopy = content;
            let typeLabel = 'Zawarto≈õƒá';

            // NAJPIERW: Spr√≥buj sparsowaƒá jako JSON (priorytet dla JSON)
            try {
                const parsed = JSON.parse(content);
                // Je≈õli parsuje siƒô jako JSON, formatuj je≈õli checkbox jest zaznaczony
                if (formatCheckbox.checked) {
                    textToCopy = JSON.stringify(parsed, null, 2);
                }
                typeLabel = 'JSON';
            } catch (jsonError) {
                // Nie jest poprawnym JSON - sprawd≈∫ typ
                const detection = detectContentType(content);
                typeLabel = detection.type === 'js' ? 'Kod JavaScript' : 'Zawarto≈õƒá';
            }

            navigator.clipboard.writeText(textToCopy).then(() => {
                showMessage(`‚úì ${typeLabel} skopiowany do schowka!`);
            }).catch(() => {
                // Fallback dla starszych przeglƒÖdarek
                const textarea = document.createElement('textarea');
                textarea.value = textToCopy;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showMessage(`‚úì ${typeLabel} skopiowany do schowka!`);
            });
        }

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const isJSFile = file.name.toLowerCase().endsWith('.js');
                    
                    // Resetuj orygina≈Ç przed wczytaniem nowego pliku
                    originalJSONBeforeStructure = null;
                    document.getElementById('restoreBtn').style.display = 'none';
                    
                    // Je≈õli to plik JS, po prostu wczytaj
                    if (isJSFile) {
                        jsonInput.value = content;
                        filenameInput.value = file.name.replace(/\.js$/i, '') || 'code';
                        updateContentTypeIndicator();
                        saveToLocalStorage();
                        showMessage('‚úì Plik JavaScript wczytany pomy≈õlnie!');
                        jsonInput.classList.remove('error');
                        return;
                    }
                    
                    // Spr√≥buj jako JSON
                    try {
                        const parsed = JSON.parse(content);
                        jsonInput.value = formatCheckbox.checked 
                            ? JSON.stringify(parsed, null, 2)
                            : content;
                        
                        // Ustaw nazwƒô pliku na podstawie workflow n8n
                        if (isN8NWorkflow(parsed) && parsed.name) {
                            filenameInput.value = parsed.name.replace(/[^a-z0-9_-]/gi, '_');
                        } else {
                            filenameInput.value = file.name.replace(/\.(json|txt)$/i, '') || 'data';
                        }
                        
                        updateStats();
                        updateContentTypeIndicator();
                        saveToLocalStorage();
                        showMessage('‚úì Plik JSON wczytany pomy≈õlnie!');
                        jsonInput.classList.remove('error');
                    } catch (jsonErr) {
                        // Je≈õli nie jest JSON, wczytaj jako tekst (mo≈ºe byƒá JS)
                        jsonInput.value = content;
                        filenameInput.value = file.name.replace(/\.[^.]+$/i, '') || 'data';
                        updateContentTypeIndicator();
                        saveToLocalStorage();
                        showMessage('‚úì Plik wczytany jako tekst!');
                        jsonInput.classList.remove('error');
                    }
                } catch (err) {
                    showMessage('B≈ÇƒÖd: ' + err.message, true);
                    jsonInput.classList.add('error');
                }
            };
            reader.onerror = () => {
                showMessage('B≈ÇƒÖd podczas wczytywania pliku', true);
            };
            reader.readAsText(file);
        }

        // Drag & Drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const isJSON = file.name.toLowerCase().endsWith('.json') || file.type.includes('json');
                const isJS = file.name.toLowerCase().endsWith('.js') || file.type.includes('javascript');
                if (isJSON || isJS || file.type === '' || file.type === 'text/plain') {
                    loadFile(file);
                } else {
                    showMessage('Proszƒô wybraƒá plik JSON lub JavaScript', true);
                }
            }
        });

        // Wczytywanie pliku przez input
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadFile(file);
            }
        });

        function clearInput() {
            jsonInput.value = '';
            filenameInput.value = 'data';
            message.className = 'message';
            jsonInput.classList.remove('error');
            updateContentTypeIndicator();
            updateStats();
            originalJSONBeforeStructure = null;
            document.getElementById('restoreBtn').style.display = 'none';
            if (autoSaveCheckbox.checked) {
                localStorage.removeItem('jsonEditor_data');
            }
            jsonInput.focus();
        }

        // Auto-walidacja i statystyki podczas pisania
        let validationTimeout;
        let lastContentLength = 0;
        jsonInput.addEventListener('input', () => {
            clearTimeout(validationTimeout);
            jsonInput.classList.remove('error');
            message.className = 'message';
            
            // Resetuj orygina≈Ç je≈õli zawarto≈õƒá zmieni≈Ça siƒô drastycznie (np. wklejenie nowego JSON)
            const currentLength = jsonInput.value.length;
            if (Math.abs(currentLength - lastContentLength) > 100) {
                // Du≈ºa zmiana - prawdopodobnie wklejono nowy JSON
                originalJSONBeforeStructure = null;
                document.getElementById('restoreBtn').style.display = 'none';
            }
            lastContentLength = currentLength;
            
            updateContentTypeIndicator();
            updateStats();
            saveToLocalStorage();
        });

        // Aktualizuj statystyki przy zmianie opcji formatowania
        formatCheckbox.addEventListener('change', () => {
            const content = jsonInput.value.trim();
            if (content) {
                // NAJPIERW: Spr√≥buj sparsowaƒá jako JSON (priorytet dla JSON)
                try {
                    const parsed = JSON.parse(content);
                    // Je≈õli parsuje siƒô jako JSON, formatuj/minifikuj
                    jsonInput.value = formatCheckbox.checked 
                        ? JSON.stringify(parsed, null, 2)
                        : JSON.stringify(parsed);
                    updateStats();
                    updateContentTypeIndicator();
                    saveToLocalStorage();
                } catch (e) {
                    // Je≈õli nie mo≈ºna sparsowaƒá jako JSON, nie r√≥b nic (mo≈ºe byƒá JS lub inny typ)
                    // Nie pokazuj b≈Çƒôdu - u≈ºytkownik mo≈ºe mieƒá niepoprawny JSON w trakcie edycji
                }
            }
        });

        // Enter + Ctrl/Cmd do pobrania
        jsonInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                downloadJSON();
            }
        });
    </script>
</body>
</html>

